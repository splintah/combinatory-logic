<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Function.Equivalence.Reasoning</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- Reasoning about _⇔_</a>
<a id="97" class="Comment">--</a>
<a id="100" class="Comment">-- NOTE: we don’t use Relation.Binary.IsEquivalence here, since we’re reasoning</a>
<a id="180" class="Comment">-- about a heterogeneous equivalence relation (i.e., the types of the operands</a>
<a id="259" class="Comment">-- of _⇔_, which are themselves types, can be of different levels). In the proof</a>
<a id="340" class="Comment">-- of Chapter₁₅.problem₁, the fact that _⇔_ is heterogeneous is actually used,</a>
<a id="419" class="Comment">-- so we cannot use a homogeneous version of _⇔_.</a>
<a id="469" class="Comment">------------------------------------------------------------------------</a>

<a id="543" class="Keyword">module</a> <a id="550" href="Function.Equivalence.Reasoning.html" class="Module">Function.Equivalence.Reasoning</a> <a id="581" class="Keyword">where</a>

<a id="588" class="Keyword">open</a> <a id="593" class="Keyword">import</a> <a id="600" href="Function.html" class="Module">Function</a> <a id="609" class="Keyword">using</a> <a id="615" class="Symbol">(</a><a id="616" href="Function.Bundles.html#8509" class="Function Operator">_⇔_</a><a id="619" class="Symbol">)</a>
<a id="621" class="Keyword">open</a> <a id="626" class="Keyword">import</a> <a id="633" href="Function.Construct.Composition.html" class="Module">Function.Construct.Composition</a> <a id="664" class="Keyword">using</a> <a id="670" class="Symbol">(</a><a id="671" href="Function.Construct.Composition.html#8919" class="Function Operator">_∘-⇔_</a><a id="676" class="Symbol">)</a> <a id="678" class="Keyword">public</a>
<a id="685" class="Keyword">open</a> <a id="690" class="Keyword">import</a> <a id="697" href="Function.Construct.Identity.html" class="Module">Function.Construct.Identity</a> <a id="725" class="Keyword">using</a> <a id="731" class="Symbol">(</a><a id="732" href="Function.Construct.Identity.html#4105" class="Function">id-⇔</a><a id="736" class="Symbol">)</a> <a id="738" class="Keyword">public</a>
<a id="745" class="Keyword">open</a> <a id="750" class="Keyword">import</a> <a id="757" href="Function.Construct.Symmetry.html" class="Module">Function.Construct.Symmetry</a> <a id="785" class="Keyword">using</a> <a id="791" class="Symbol">(</a><a id="792" href="Function.Construct.Symmetry.html#3270" class="Function">sym-⇔</a><a id="797" class="Symbol">)</a> <a id="799" class="Keyword">public</a>
<a id="806" class="Keyword">open</a> <a id="811" class="Keyword">import</a> <a id="818" href="Level.html" class="Module">Level</a> <a id="824" class="Keyword">using</a> <a id="830" class="Symbol">(</a><a id="831" href="Agda.Primitive.html#423" class="Postulate">Level</a><a id="836" class="Symbol">)</a>

<a id="839" class="Keyword">private</a>
  <a id="849" class="Keyword">variable</a>
    <a id="862" href="Function.Equivalence.Reasoning.html#862" class="Generalizable">a</a> <a id="864" href="Function.Equivalence.Reasoning.html#864" class="Generalizable">b</a> <a id="866" href="Function.Equivalence.Reasoning.html#866" class="Generalizable">c</a> <a id="868" class="Symbol">:</a> <a id="870" href="Agda.Primitive.html#423" class="Postulate">Level</a>

<a id="877" class="Keyword">infix</a>  <a id="884" class="Number">1</a> <a id="886" href="Function.Equivalence.Reasoning.html#936" class="Function Operator">begin_</a>
<a id="893" class="Keyword">infixr</a> <a id="900" class="Number">2</a> <a id="902" href="Function.Equivalence.Reasoning.html#1040" class="Function Operator">_⇔⟨⟩_</a> <a id="908" href="Function.Equivalence.Reasoning.html#1105" class="Function">step-⇔</a> <a id="915" href="Function.Equivalence.Reasoning.html#1234" class="Function">step-⇔˘</a>
<a id="923" class="Keyword">infix</a>  <a id="930" class="Number">3</a> <a id="932" href="Function.Equivalence.Reasoning.html#1002" class="Function Operator">_∎</a>

<a id="begin_"></a><a id="936" href="Function.Equivalence.Reasoning.html#936" class="Function Operator">begin_</a> <a id="943" class="Symbol">:</a> <a id="945" class="Symbol">{</a><a id="946" href="Function.Equivalence.Reasoning.html#946" class="Bound">A</a> <a id="948" class="Symbol">:</a> <a id="950" class="PrimitiveType">Set</a> <a id="954" href="Function.Equivalence.Reasoning.html#862" class="Generalizable">a</a><a id="955" class="Symbol">}</a> <a id="957" class="Symbol">{</a><a id="958" href="Function.Equivalence.Reasoning.html#958" class="Bound">B</a> <a id="960" class="Symbol">:</a> <a id="962" class="PrimitiveType">Set</a> <a id="966" href="Function.Equivalence.Reasoning.html#864" class="Generalizable">b</a><a id="967" class="Symbol">}</a> <a id="969" class="Symbol">→</a> <a id="971" href="Function.Equivalence.Reasoning.html#946" class="Bound">A</a> <a id="973" href="Function.Bundles.html#8509" class="Function Operator">⇔</a> <a id="975" href="Function.Equivalence.Reasoning.html#958" class="Bound">B</a> <a id="977" class="Symbol">→</a> <a id="979" href="Function.Equivalence.Reasoning.html#946" class="Bound">A</a> <a id="981" href="Function.Bundles.html#8509" class="Function Operator">⇔</a> <a id="983" href="Function.Equivalence.Reasoning.html#958" class="Bound">B</a>
<a id="985" href="Function.Equivalence.Reasoning.html#936" class="Function Operator">begin</a> <a id="991" href="Function.Equivalence.Reasoning.html#991" class="Bound">A⇔B</a> <a id="995" class="Symbol">=</a> <a id="997" href="Function.Equivalence.Reasoning.html#991" class="Bound">A⇔B</a>

<a id="_∎"></a><a id="1002" href="Function.Equivalence.Reasoning.html#1002" class="Function Operator">_∎</a> <a id="1005" class="Symbol">:</a> <a id="1007" class="Symbol">∀</a> <a id="1009" class="Symbol">(</a><a id="1010" href="Function.Equivalence.Reasoning.html#1010" class="Bound">A</a> <a id="1012" class="Symbol">:</a> <a id="1014" class="PrimitiveType">Set</a> <a id="1018" href="Function.Equivalence.Reasoning.html#862" class="Generalizable">a</a><a id="1019" class="Symbol">)</a> <a id="1021" class="Symbol">→</a> <a id="1023" href="Function.Equivalence.Reasoning.html#1010" class="Bound">A</a> <a id="1025" href="Function.Bundles.html#8509" class="Function Operator">⇔</a> <a id="1027" href="Function.Equivalence.Reasoning.html#1010" class="Bound">A</a>
<a id="1029" href="Function.Equivalence.Reasoning.html#1002" class="Function Operator">_∎</a> <a id="1032" class="Symbol">=</a> <a id="1034" href="Function.Construct.Identity.html#4105" class="Function">id-⇔</a>

<a id="_⇔⟨⟩_"></a><a id="1040" href="Function.Equivalence.Reasoning.html#1040" class="Function Operator">_⇔⟨⟩_</a> <a id="1046" class="Symbol">:</a> <a id="1048" class="Symbol">(</a><a id="1049" href="Function.Equivalence.Reasoning.html#1049" class="Bound">A</a> <a id="1051" class="Symbol">:</a> <a id="1053" class="PrimitiveType">Set</a> <a id="1057" href="Function.Equivalence.Reasoning.html#862" class="Generalizable">a</a><a id="1058" class="Symbol">)</a> <a id="1060" class="Symbol">{</a><a id="1061" href="Function.Equivalence.Reasoning.html#1061" class="Bound">B</a> <a id="1063" class="Symbol">:</a> <a id="1065" class="PrimitiveType">Set</a> <a id="1069" href="Function.Equivalence.Reasoning.html#864" class="Generalizable">b</a><a id="1070" class="Symbol">}</a> <a id="1072" class="Symbol">→</a> <a id="1074" href="Function.Equivalence.Reasoning.html#1049" class="Bound">A</a> <a id="1076" href="Function.Bundles.html#8509" class="Function Operator">⇔</a> <a id="1078" href="Function.Equivalence.Reasoning.html#1061" class="Bound">B</a> <a id="1080" class="Symbol">→</a> <a id="1082" href="Function.Equivalence.Reasoning.html#1049" class="Bound">A</a> <a id="1084" href="Function.Bundles.html#8509" class="Function Operator">⇔</a> <a id="1086" href="Function.Equivalence.Reasoning.html#1061" class="Bound">B</a>
<a id="1088" href="Function.Equivalence.Reasoning.html#1088" class="Bound">A</a> <a id="1090" href="Function.Equivalence.Reasoning.html#1040" class="Function Operator">⇔⟨⟩</a> <a id="1094" href="Function.Equivalence.Reasoning.html#1094" class="Bound">A⇔B</a> <a id="1098" class="Symbol">=</a> <a id="1100" href="Function.Equivalence.Reasoning.html#1094" class="Bound">A⇔B</a>

<a id="step-⇔"></a><a id="1105" href="Function.Equivalence.Reasoning.html#1105" class="Function">step-⇔</a> <a id="1112" class="Symbol">:</a> <a id="1114" class="Symbol">(</a><a id="1115" href="Function.Equivalence.Reasoning.html#1115" class="Bound">A</a> <a id="1117" class="Symbol">:</a> <a id="1119" class="PrimitiveType">Set</a> <a id="1123" href="Function.Equivalence.Reasoning.html#862" class="Generalizable">a</a><a id="1124" class="Symbol">)</a> <a id="1126" class="Symbol">{</a><a id="1127" href="Function.Equivalence.Reasoning.html#1127" class="Bound">B</a> <a id="1129" class="Symbol">:</a> <a id="1131" class="PrimitiveType">Set</a> <a id="1135" href="Function.Equivalence.Reasoning.html#864" class="Generalizable">b</a><a id="1136" class="Symbol">}</a> <a id="1138" class="Symbol">{</a><a id="1139" href="Function.Equivalence.Reasoning.html#1139" class="Bound">C</a> <a id="1141" class="Symbol">:</a> <a id="1143" class="PrimitiveType">Set</a> <a id="1147" href="Function.Equivalence.Reasoning.html#866" class="Generalizable">c</a><a id="1148" class="Symbol">}</a> <a id="1150" class="Symbol">→</a> <a id="1152" href="Function.Equivalence.Reasoning.html#1115" class="Bound">A</a> <a id="1154" href="Function.Bundles.html#8509" class="Function Operator">⇔</a> <a id="1156" href="Function.Equivalence.Reasoning.html#1127" class="Bound">B</a> <a id="1158" class="Symbol">→</a> <a id="1160" href="Function.Equivalence.Reasoning.html#1127" class="Bound">B</a> <a id="1162" href="Function.Bundles.html#8509" class="Function Operator">⇔</a> <a id="1164" href="Function.Equivalence.Reasoning.html#1139" class="Bound">C</a> <a id="1166" class="Symbol">→</a> <a id="1168" href="Function.Equivalence.Reasoning.html#1115" class="Bound">A</a> <a id="1170" href="Function.Bundles.html#8509" class="Function Operator">⇔</a> <a id="1172" href="Function.Equivalence.Reasoning.html#1139" class="Bound">C</a>
<a id="1174" href="Function.Equivalence.Reasoning.html#1105" class="Function">step-⇔</a> <a id="1181" href="Function.Equivalence.Reasoning.html#1181" class="Bound">A</a> <a id="1183" class="Symbol">=</a> <a id="1185" href="Function.Construct.Composition.html#8919" class="Function Operator">_∘-⇔_</a>

<a id="1192" class="Keyword">syntax</a> <a id="1199" href="Function.Equivalence.Reasoning.html#1105" class="Function">step-⇔</a> <a id="1206" class="Bound">A</a> <a id="1208" class="Bound">A⇔B</a> <a id="1212" class="Bound">B⇔C</a> <a id="1216" class="Symbol">=</a> <a id="1218" class="Bound">A</a> <a id="1220" class="Function">⇔⟨</a> <a id="1223" class="Bound">A⇔B</a> <a id="1227" class="Function">⟩</a> <a id="1229" class="Bound">B⇔C</a>

<a id="step-⇔˘"></a><a id="1234" href="Function.Equivalence.Reasoning.html#1234" class="Function">step-⇔˘</a> <a id="1242" class="Symbol">:</a> <a id="1244" class="Symbol">(</a><a id="1245" href="Function.Equivalence.Reasoning.html#1245" class="Bound">A</a> <a id="1247" class="Symbol">:</a> <a id="1249" class="PrimitiveType">Set</a> <a id="1253" href="Function.Equivalence.Reasoning.html#862" class="Generalizable">a</a><a id="1254" class="Symbol">)</a> <a id="1256" class="Symbol">{</a><a id="1257" href="Function.Equivalence.Reasoning.html#1257" class="Bound">B</a> <a id="1259" class="Symbol">:</a> <a id="1261" class="PrimitiveType">Set</a> <a id="1265" href="Function.Equivalence.Reasoning.html#864" class="Generalizable">b</a><a id="1266" class="Symbol">}</a> <a id="1268" class="Symbol">{</a><a id="1269" href="Function.Equivalence.Reasoning.html#1269" class="Bound">C</a> <a id="1271" class="Symbol">:</a> <a id="1273" class="PrimitiveType">Set</a> <a id="1277" href="Function.Equivalence.Reasoning.html#866" class="Generalizable">c</a><a id="1278" class="Symbol">}</a> <a id="1280" class="Symbol">→</a> <a id="1282" href="Function.Equivalence.Reasoning.html#1257" class="Bound">B</a> <a id="1284" href="Function.Bundles.html#8509" class="Function Operator">⇔</a> <a id="1286" href="Function.Equivalence.Reasoning.html#1245" class="Bound">A</a> <a id="1288" class="Symbol">→</a> <a id="1290" href="Function.Equivalence.Reasoning.html#1257" class="Bound">B</a> <a id="1292" href="Function.Bundles.html#8509" class="Function Operator">⇔</a> <a id="1294" href="Function.Equivalence.Reasoning.html#1269" class="Bound">C</a> <a id="1296" class="Symbol">→</a> <a id="1298" href="Function.Equivalence.Reasoning.html#1245" class="Bound">A</a> <a id="1300" href="Function.Bundles.html#8509" class="Function Operator">⇔</a> <a id="1302" href="Function.Equivalence.Reasoning.html#1269" class="Bound">C</a>
<a id="1304" href="Function.Equivalence.Reasoning.html#1234" class="Function">step-⇔˘</a> <a id="1312" href="Function.Equivalence.Reasoning.html#1312" class="Bound">A</a> <a id="1314" href="Function.Equivalence.Reasoning.html#1314" class="Bound">B⇔A</a> <a id="1318" href="Function.Equivalence.Reasoning.html#1318" class="Bound">B⇔C</a> <a id="1322" class="Symbol">=</a> <a id="1324" href="Function.Equivalence.Reasoning.html#1312" class="Bound">A</a> <a id="1326" href="Function.Equivalence.Reasoning.html#1105" class="Function">⇔⟨</a> <a id="1329" href="Function.Construct.Symmetry.html#3270" class="Function">sym-⇔</a> <a id="1335" href="Function.Equivalence.Reasoning.html#1314" class="Bound">B⇔A</a> <a id="1339" href="Function.Equivalence.Reasoning.html#1105" class="Function">⟩</a> <a id="1341" href="Function.Equivalence.Reasoning.html#1318" class="Bound">B⇔C</a>

<a id="1346" class="Keyword">syntax</a> <a id="1353" href="Function.Equivalence.Reasoning.html#1234" class="Function">step-⇔˘</a> <a id="1361" class="Bound">A</a> <a id="1363" class="Bound">B⇔A</a> <a id="1367" class="Bound">B⇔C</a> <a id="1371" class="Symbol">=</a> <a id="1373" class="Bound">A</a> <a id="1375" class="Function">⇔˘⟨</a> <a id="1379" class="Bound">B⇔A</a> <a id="1383" class="Function">⟩</a> <a id="1385" class="Bound">B⇔C</a>
</pre></body></html>