<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Function.Equivalence.Reasoning</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- Reasoning about _⇔_</a>
<a id="97" class="Comment">--</a>
<a id="100" class="Comment">-- NOTE: we don’t use Relation.Binary.IsEquivalence here, since we’re reasoning</a>
<a id="180" class="Comment">-- about a heterogeneous equivalence relation (i.e., the types of the operands</a>
<a id="259" class="Comment">-- of _⇔_, which are themselves types, can be of different levels). In the proof</a>
<a id="340" class="Comment">-- of Chapter₁₅.problem₁, the fact that _⇔_ is heterogeneous is actually used,</a>
<a id="419" class="Comment">-- so we cannot use a homogeneous version of _⇔_.</a>
<a id="469" class="Comment">------------------------------------------------------------------------</a>

<a id="543" class="Keyword">module</a> <a id="550" href="Function.Equivalence.Reasoning.html" class="Module">Function.Equivalence.Reasoning</a> <a id="581" class="Keyword">where</a>

<a id="588" class="Keyword">open</a> <a id="593" class="Keyword">import</a> <a id="600" href="Function.html" class="Module">Function</a> <a id="609" class="Keyword">using</a> <a id="615" class="Symbol">(</a><a id="616" href="Function.Bundles.html#8509" class="Function Operator">_⇔_</a><a id="619" class="Symbol">)</a>
<a id="621" class="Keyword">open</a> <a id="626" class="Keyword">import</a> <a id="633" href="Function.Construct.Composition.html" class="Module">Function.Construct.Composition</a> <a id="664" class="Keyword">using</a> <a id="670" class="Symbol">(</a><a id="671" href="Function.Construct.Composition.html#8919" class="Function Operator">_∘-⇔_</a><a id="676" class="Symbol">)</a> <a id="678" class="Keyword">public</a>
<a id="685" class="Keyword">open</a> <a id="690" class="Keyword">import</a> <a id="697" href="Function.Construct.Identity.html" class="Module">Function.Construct.Identity</a> <a id="725" class="Keyword">using</a> <a id="731" class="Symbol">(</a><a id="732" href="Function.Construct.Identity.html#4105" class="Function">id-⇔</a><a id="736" class="Symbol">)</a> <a id="738" class="Keyword">public</a>
<a id="745" class="Keyword">open</a> <a id="750" class="Keyword">import</a> <a id="757" href="Function.Construct.Symmetry.html" class="Module">Function.Construct.Symmetry</a> <a id="785" class="Keyword">using</a> <a id="791" class="Symbol">(</a><a id="792" href="Function.Construct.Symmetry.html#3270" class="Function">sym-⇔</a><a id="797" class="Symbol">)</a> <a id="799" class="Keyword">public</a>
<a id="806" class="Keyword">open</a> <a id="811" class="Keyword">import</a> <a id="818" href="Level.html" class="Module">Level</a> <a id="824" class="Keyword">using</a> <a id="830" class="Symbol">(</a><a id="831" href="Agda.Primitive.html#423" class="Postulate">Level</a><a id="836" class="Symbol">)</a>

<a id="839" class="Keyword">private</a>
  <a id="849" class="Keyword">variable</a>
    <a id="862" href="Function.Equivalence.Reasoning.html#862" class="Generalizable">a</a> <a id="864" href="Function.Equivalence.Reasoning.html#864" class="Generalizable">b</a> <a id="866" href="Function.Equivalence.Reasoning.html#866" class="Generalizable">c</a> <a id="868" class="Symbol">:</a> <a id="870" href="Agda.Primitive.html#423" class="Postulate">Level</a>

<a id="877" class="Keyword">infix</a>  <a id="884" class="Number">1</a> <a id="886" href="Function.Equivalence.Reasoning.html#936" class="Function Operator">begin_</a>
<a id="893" class="Keyword">infixr</a> <a id="900" class="Number">2</a> <a id="902" href="Function.Equivalence.Reasoning.html#1038" class="Function Operator">_⇔⟨⟩_</a> <a id="908" href="Function.Equivalence.Reasoning.html#1103" class="Function">step-⇔</a> <a id="915" href="Function.Equivalence.Reasoning.html#1232" class="Function">step-⇔˘</a>
<a id="923" class="Keyword">infix</a>  <a id="930" class="Number">3</a> <a id="932" href="Function.Equivalence.Reasoning.html#1002" class="Function Operator">_∎</a>

<a id="begin_"></a><a id="936" href="Function.Equivalence.Reasoning.html#936" class="Function Operator">begin_</a> <a id="943" class="Symbol">:</a> <a id="945" class="Symbol">{</a><a id="946" href="Function.Equivalence.Reasoning.html#946" class="Bound">A</a> <a id="948" class="Symbol">:</a> <a id="950" class="PrimitiveType">Set</a> <a id="954" href="Function.Equivalence.Reasoning.html#862" class="Generalizable">a</a><a id="955" class="Symbol">}</a> <a id="957" class="Symbol">{</a><a id="958" href="Function.Equivalence.Reasoning.html#958" class="Bound">B</a> <a id="960" class="Symbol">:</a> <a id="962" class="PrimitiveType">Set</a> <a id="966" href="Function.Equivalence.Reasoning.html#864" class="Generalizable">b</a><a id="967" class="Symbol">}</a> <a id="969" class="Symbol">→</a> <a id="971" href="Function.Equivalence.Reasoning.html#946" class="Bound">A</a> <a id="973" href="Function.Bundles.html#8509" class="Function Operator">⇔</a> <a id="975" href="Function.Equivalence.Reasoning.html#958" class="Bound">B</a> <a id="977" class="Symbol">→</a> <a id="979" href="Function.Equivalence.Reasoning.html#946" class="Bound">A</a> <a id="981" href="Function.Bundles.html#8509" class="Function Operator">⇔</a> <a id="983" href="Function.Equivalence.Reasoning.html#958" class="Bound">B</a>
<a id="985" href="Function.Equivalence.Reasoning.html#936" class="Function Operator">begin</a> <a id="991" href="Function.Equivalence.Reasoning.html#991" class="Bound">A⇔B</a> <a id="995" class="Symbol">=</a> <a id="997" href="Function.Equivalence.Reasoning.html#991" class="Bound">A⇔B</a>

<a id="_∎"></a><a id="1002" href="Function.Equivalence.Reasoning.html#1002" class="Function Operator">_∎</a> <a id="1005" class="Symbol">:</a> <a id="1007" class="Symbol">(</a><a id="1008" href="Function.Equivalence.Reasoning.html#1008" class="Bound">A</a> <a id="1010" class="Symbol">:</a> <a id="1012" class="PrimitiveType">Set</a> <a id="1016" href="Function.Equivalence.Reasoning.html#862" class="Generalizable">a</a><a id="1017" class="Symbol">)</a> <a id="1019" class="Symbol">→</a> <a id="1021" href="Function.Equivalence.Reasoning.html#1008" class="Bound">A</a> <a id="1023" href="Function.Bundles.html#8509" class="Function Operator">⇔</a> <a id="1025" href="Function.Equivalence.Reasoning.html#1008" class="Bound">A</a>
<a id="1027" href="Function.Equivalence.Reasoning.html#1002" class="Function Operator">_∎</a> <a id="1030" class="Symbol">=</a> <a id="1032" href="Function.Construct.Identity.html#4105" class="Function">id-⇔</a>

<a id="_⇔⟨⟩_"></a><a id="1038" href="Function.Equivalence.Reasoning.html#1038" class="Function Operator">_⇔⟨⟩_</a> <a id="1044" class="Symbol">:</a> <a id="1046" class="Symbol">(</a><a id="1047" href="Function.Equivalence.Reasoning.html#1047" class="Bound">A</a> <a id="1049" class="Symbol">:</a> <a id="1051" class="PrimitiveType">Set</a> <a id="1055" href="Function.Equivalence.Reasoning.html#862" class="Generalizable">a</a><a id="1056" class="Symbol">)</a> <a id="1058" class="Symbol">{</a><a id="1059" href="Function.Equivalence.Reasoning.html#1059" class="Bound">B</a> <a id="1061" class="Symbol">:</a> <a id="1063" class="PrimitiveType">Set</a> <a id="1067" href="Function.Equivalence.Reasoning.html#864" class="Generalizable">b</a><a id="1068" class="Symbol">}</a> <a id="1070" class="Symbol">→</a> <a id="1072" href="Function.Equivalence.Reasoning.html#1047" class="Bound">A</a> <a id="1074" href="Function.Bundles.html#8509" class="Function Operator">⇔</a> <a id="1076" href="Function.Equivalence.Reasoning.html#1059" class="Bound">B</a> <a id="1078" class="Symbol">→</a> <a id="1080" href="Function.Equivalence.Reasoning.html#1047" class="Bound">A</a> <a id="1082" href="Function.Bundles.html#8509" class="Function Operator">⇔</a> <a id="1084" href="Function.Equivalence.Reasoning.html#1059" class="Bound">B</a>
<a id="1086" href="Function.Equivalence.Reasoning.html#1086" class="Bound">A</a> <a id="1088" href="Function.Equivalence.Reasoning.html#1038" class="Function Operator">⇔⟨⟩</a> <a id="1092" href="Function.Equivalence.Reasoning.html#1092" class="Bound">A⇔B</a> <a id="1096" class="Symbol">=</a> <a id="1098" href="Function.Equivalence.Reasoning.html#1092" class="Bound">A⇔B</a>

<a id="step-⇔"></a><a id="1103" href="Function.Equivalence.Reasoning.html#1103" class="Function">step-⇔</a> <a id="1110" class="Symbol">:</a> <a id="1112" class="Symbol">(</a><a id="1113" href="Function.Equivalence.Reasoning.html#1113" class="Bound">A</a> <a id="1115" class="Symbol">:</a> <a id="1117" class="PrimitiveType">Set</a> <a id="1121" href="Function.Equivalence.Reasoning.html#862" class="Generalizable">a</a><a id="1122" class="Symbol">)</a> <a id="1124" class="Symbol">{</a><a id="1125" href="Function.Equivalence.Reasoning.html#1125" class="Bound">B</a> <a id="1127" class="Symbol">:</a> <a id="1129" class="PrimitiveType">Set</a> <a id="1133" href="Function.Equivalence.Reasoning.html#864" class="Generalizable">b</a><a id="1134" class="Symbol">}</a> <a id="1136" class="Symbol">{</a><a id="1137" href="Function.Equivalence.Reasoning.html#1137" class="Bound">C</a> <a id="1139" class="Symbol">:</a> <a id="1141" class="PrimitiveType">Set</a> <a id="1145" href="Function.Equivalence.Reasoning.html#866" class="Generalizable">c</a><a id="1146" class="Symbol">}</a> <a id="1148" class="Symbol">→</a> <a id="1150" href="Function.Equivalence.Reasoning.html#1113" class="Bound">A</a> <a id="1152" href="Function.Bundles.html#8509" class="Function Operator">⇔</a> <a id="1154" href="Function.Equivalence.Reasoning.html#1125" class="Bound">B</a> <a id="1156" class="Symbol">→</a> <a id="1158" href="Function.Equivalence.Reasoning.html#1125" class="Bound">B</a> <a id="1160" href="Function.Bundles.html#8509" class="Function Operator">⇔</a> <a id="1162" href="Function.Equivalence.Reasoning.html#1137" class="Bound">C</a> <a id="1164" class="Symbol">→</a> <a id="1166" href="Function.Equivalence.Reasoning.html#1113" class="Bound">A</a> <a id="1168" href="Function.Bundles.html#8509" class="Function Operator">⇔</a> <a id="1170" href="Function.Equivalence.Reasoning.html#1137" class="Bound">C</a>
<a id="1172" href="Function.Equivalence.Reasoning.html#1103" class="Function">step-⇔</a> <a id="1179" href="Function.Equivalence.Reasoning.html#1179" class="Bound">A</a> <a id="1181" class="Symbol">=</a> <a id="1183" href="Function.Construct.Composition.html#8919" class="Function Operator">_∘-⇔_</a>

<a id="1190" class="Keyword">syntax</a> <a id="1197" href="Function.Equivalence.Reasoning.html#1103" class="Function">step-⇔</a> <a id="1204" class="Bound">A</a> <a id="1206" class="Bound">A⇔B</a> <a id="1210" class="Bound">B⇔C</a> <a id="1214" class="Symbol">=</a> <a id="1216" class="Bound">A</a> <a id="1218" class="Function">⇔⟨</a> <a id="1221" class="Bound">A⇔B</a> <a id="1225" class="Function">⟩</a> <a id="1227" class="Bound">B⇔C</a>

<a id="step-⇔˘"></a><a id="1232" href="Function.Equivalence.Reasoning.html#1232" class="Function">step-⇔˘</a> <a id="1240" class="Symbol">:</a> <a id="1242" class="Symbol">(</a><a id="1243" href="Function.Equivalence.Reasoning.html#1243" class="Bound">A</a> <a id="1245" class="Symbol">:</a> <a id="1247" class="PrimitiveType">Set</a> <a id="1251" href="Function.Equivalence.Reasoning.html#862" class="Generalizable">a</a><a id="1252" class="Symbol">)</a> <a id="1254" class="Symbol">{</a><a id="1255" href="Function.Equivalence.Reasoning.html#1255" class="Bound">B</a> <a id="1257" class="Symbol">:</a> <a id="1259" class="PrimitiveType">Set</a> <a id="1263" href="Function.Equivalence.Reasoning.html#864" class="Generalizable">b</a><a id="1264" class="Symbol">}</a> <a id="1266" class="Symbol">{</a><a id="1267" href="Function.Equivalence.Reasoning.html#1267" class="Bound">C</a> <a id="1269" class="Symbol">:</a> <a id="1271" class="PrimitiveType">Set</a> <a id="1275" href="Function.Equivalence.Reasoning.html#866" class="Generalizable">c</a><a id="1276" class="Symbol">}</a> <a id="1278" class="Symbol">→</a> <a id="1280" href="Function.Equivalence.Reasoning.html#1255" class="Bound">B</a> <a id="1282" href="Function.Bundles.html#8509" class="Function Operator">⇔</a> <a id="1284" href="Function.Equivalence.Reasoning.html#1243" class="Bound">A</a> <a id="1286" class="Symbol">→</a> <a id="1288" href="Function.Equivalence.Reasoning.html#1255" class="Bound">B</a> <a id="1290" href="Function.Bundles.html#8509" class="Function Operator">⇔</a> <a id="1292" href="Function.Equivalence.Reasoning.html#1267" class="Bound">C</a> <a id="1294" class="Symbol">→</a> <a id="1296" href="Function.Equivalence.Reasoning.html#1243" class="Bound">A</a> <a id="1298" href="Function.Bundles.html#8509" class="Function Operator">⇔</a> <a id="1300" href="Function.Equivalence.Reasoning.html#1267" class="Bound">C</a>
<a id="1302" href="Function.Equivalence.Reasoning.html#1232" class="Function">step-⇔˘</a> <a id="1310" href="Function.Equivalence.Reasoning.html#1310" class="Bound">A</a> <a id="1312" href="Function.Equivalence.Reasoning.html#1312" class="Bound">B⇔A</a> <a id="1316" href="Function.Equivalence.Reasoning.html#1316" class="Bound">B⇔C</a> <a id="1320" class="Symbol">=</a> <a id="1322" href="Function.Equivalence.Reasoning.html#1310" class="Bound">A</a> <a id="1324" href="Function.Equivalence.Reasoning.html#1103" class="Function">⇔⟨</a> <a id="1327" href="Function.Construct.Symmetry.html#3270" class="Function">sym-⇔</a> <a id="1333" href="Function.Equivalence.Reasoning.html#1312" class="Bound">B⇔A</a> <a id="1337" href="Function.Equivalence.Reasoning.html#1103" class="Function">⟩</a> <a id="1339" href="Function.Equivalence.Reasoning.html#1316" class="Bound">B⇔C</a>

<a id="1344" class="Keyword">syntax</a> <a id="1351" href="Function.Equivalence.Reasoning.html#1232" class="Function">step-⇔˘</a> <a id="1359" class="Bound">A</a> <a id="1361" class="Bound">B⇔A</a> <a id="1365" class="Bound">B⇔C</a> <a id="1369" class="Symbol">=</a> <a id="1371" class="Bound">A</a> <a id="1373" class="Function">⇔˘⟨</a> <a id="1377" class="Bound">B⇔A</a> <a id="1381" class="Function">⟩</a> <a id="1383" class="Bound">B⇔C</a>
</pre></body></html>